<!-- Dreamscapes Hero Section - Boids Particle Effect -->
<style>
    /* Scope styles to avoid conflicts */
    .dreamscapes-hero-wrapper {
        position: relative;
        width: 100%;
        height: 100vh;
        /* Full viewport height */
        min-height: 600px;
        background: #0a0a0a;
        overflow: hidden;
        font-family: 'Montserrat', sans-serif;
    }

    #particle-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    .ds-hero-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        text-align: center;
        opacity: 0;
        animation: dsFadeIn 1s ease-out 0.5s forwards;
        pointer-events: none;
        /* Let clicks pass through to canvas if needed, though buttons are distinct */
        width: 100%;
        padding: 0 20px;
    }

    .ds-hero-content h1 {
        font-size: 4rem;
        font-weight: 700;
        color: #ffffff;
        margin-bottom: 1rem;
        text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        line-height: 1.2;
    }

    .ds-subtitle {
        font-size: 1.5rem;
        color: #d4a5a5;
        margin-bottom: 2rem;
        display: block;
    }

    .ds-cta-buttons {
        display: flex;
        gap: 1rem;
        justify-content: center;
        pointer-events: all;
        /* Re-enable clicks for buttons */
    }

    .ds-btn {
        padding: 15px 40px;
        font-size: 1rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
        border-radius: 8px;
        text-decoration: none;
        transition: all 0.3s ease;
        cursor: pointer;
        border: none;
        display: inline-block;
    }

    .ds-btn-primary {
        background-color: #ffffff;
        color: #0a0a0a;
        box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
    }

    .ds-btn-primary:hover {
        background-color: #e0e0e0;
        box-shadow: 0 0 25px rgba(255, 255, 255, 0.5);
        transform: translateY(-2px);
    }

    .ds-btn-secondary {
        background-color: transparent;
        color: #ffffff;
        border: 2px solid #ffffff;
    }

    .ds-btn-secondary:hover {
        background-color: rgba(255, 255, 255, 0.1);
        transform: translateY(-2px);
    }

    @keyframes dsFadeIn {
        to {
            opacity: 1;
        }
    }

    @media (max-width: 768px) {
        .ds-hero-content h1 {
            font-size: 2.5rem;
        }

        .ds-subtitle {
            font-size: 1.2rem;
        }

        .ds-cta-buttons {
            flex-direction: column;
            align-items: center;
        }

        .ds-btn {
            width: 100%;
            max-width: 300px;
        }
    }
</style>

<div class="dreamscapes-hero-wrapper">
    <canvas id="particle-canvas"></canvas>

    <div class="ds-hero-content">
        <h1>Dreamscapes Goods</h1>
        <span class="ds-subtitle">Unique designs inspired by dreams and the cosmos</span>
        <div class="ds-cta-buttons">
            <a href="/shop" class="ds-btn ds-btn-primary">Explore Collection</a>
            <a href="/about" class="ds-btn ds-btn-secondary">Learn More</a>
        </div>
    </div>
</div>

<script>
    (function () {
        const canvas = document.getElementById('particle-canvas');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');

        // Vector Class
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            setMag(n) { this.normalize().mult(n); return this; }
            normalize() {
                let m = this.mag();
                if (m !== 0) { this.div(m); }
                return this;
            }
            limit(max) {
                if (this.mag() > max) { this.normalize().mult(max); }
                return this;
            }
            static dist(v1, v2) {
                let dx = v1.x - v2.x;
                let dy = v1.y - v2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static add(v1, v2) { return new Vector(v1.x + v2.x, v1.y + v2.y); }
        }

        const config = {
            count: 350,
            maxSpeed: 6,
            maxForce: 0.15,
            perceptionRadius: 60,
            separationDist: 35,
            mouseInfluence: 1.5,
            colorSpeed: 0.5
        };

        let boids = [];
        let mouse = new Vector(window.innerWidth / 2, window.innerHeight / 2);
        let animationFrameId;

        class Boid {
            constructor(x, y) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(Math.random() - 0.5, Math.random() - 0.5);
                this.velocity.setMag(Math.random() * 2 + 2);
                this.acceleration = new Vector(0, 0);
                this.size = 2 + Math.random() * 3;
                // Random start hue in Blue-Purple-Pink range
                this.hue = 240 + Math.random() * 100;
            }

            separation(boids) {
                let steering = new Vector(0, 0);
                let total = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.position, other.position);
                    if (other !== this && d < config.separationDist) {
                        let diff = Vector.sub(this.position, other.position);
                        diff.normalize();
                        diff.div(d);
                        steering.add(diff);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.div(total);
                    steering.setMag(config.maxSpeed);
                    steering.sub(this.velocity);
                    steering.limit(config.maxForce * 1.5);
                }
                return steering;
            }

            alignment(boids) {
                let steering = new Vector(0, 0);
                let total = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.position, other.position);
                    if (other !== this && d < config.perceptionRadius) {
                        steering.add(other.velocity);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.div(total);
                    steering.setMag(config.maxSpeed);
                    steering.sub(this.velocity);
                    steering.limit(config.maxForce);
                }
                return steering;
            }

            cohesion(boids) {
                let steering = new Vector(0, 0);
                let total = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.position, other.position);
                    if (other !== this && d < config.perceptionRadius) {
                        steering.add(other.position);
                        total++;
                    }
                }
                if (total > 0) {
                    steering.div(total);
                    steering.sub(this.position);
                    steering.setMag(config.maxSpeed);
                    steering.sub(this.velocity);
                    steering.limit(config.maxForce);
                }
                return steering;
            }

            seek(target) {
                let desired = Vector.sub(target, this.position);
                let d = desired.mag();
                if (d < 100) {
                    let m = (d / 100) * config.maxSpeed;
                    desired.setMag(m);
                } else {
                    desired.setMag(config.maxSpeed);
                }
                let steer = Vector.sub(desired, this.velocity);
                steer.limit(config.maxForce * config.mouseInfluence);
                return steer;
            }

            flock(boids) {
                let sep = this.separation(boids);
                let ali = this.alignment(boids);
                let coh = this.cohesion(boids);
                // Seek mouse but keep formation
                let seek = this.seek(mouse);

                sep.mult(2.5);
                ali.mult(1.0);
                coh.mult(1.0);
                seek.mult(1.5);

                this.acceleration.add(sep);
                this.acceleration.add(ali);
                this.acceleration.add(coh);
                this.acceleration.add(seek);
            }

            update() {
                this.velocity.add(this.acceleration);
                this.velocity.limit(config.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.mult(0);

                // Subtle color shift
                this.hue = (this.hue + 0.5) % 360;
            }

            draw() {
                let theta = Math.atan2(this.velocity.y, this.velocity.x);
                let speed = this.velocity.mag();

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(theta);

                // Map color to angle around mouse for consistent gradient look
                let ma = Math.atan2(this.position.y - mouse.y, this.position.x - mouse.x);
                let deg = (ma * 180 / Math.PI + 360) % 360;

                ctx.fillStyle = `hsl(${deg}, 80%, 60%)`;

                ctx.beginPath();
                let len = this.size * 2 + speed * 3;
                let wid = this.size;

                ctx.ellipse(0, 0, len / 2, wid / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Init Logic
        function init() {
            boids = [];
            const w = window.innerWidth;
            const h = window.innerHeight;
            for (let i = 0; i < config.count; i++) {
                let a = Math.random() * Math.PI * 2;
                let r = 200 + Math.random() * 100;
                boids.push(new Boid(
                    w / 2 + Math.cos(a) * r,
                    h / 2 + Math.sin(a) * r
                ));
            }
            resizeCanvas();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            // Optional: Re-init or just let them fly?
            // Let them fly is smoother.
        });

        // Track mouse
        let mouseX = window.innerWidth / 2, mouseY = window.innerHeight / 2;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function animate() {
            mouse.x += (mouseX - mouse.x) * 0.1;
            mouse.y += (mouseY - mouse.y) * 0.1;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let boid of boids) {
                boid.flock(boids);
                boid.update();
                boid.draw();
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        // Start
        init();
        animate();

    })();
</script>